{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"NewerType","text":"<p>An Implementation of the NewType Pattern for Python that works in dynamic contexts.</p>"},{"location":"#what-is-it","title":"What is it?","text":"<p><code>NewerType</code> is a package that provides a semi-transparent wrapper to an existing type that allows it to be used mostly as if it's just the wrapped type, but which allows type checking as if it's a distinct type at runtime.</p> <p>With the addition to Python of PEP 483, PEP 484, &amp; the typing package, Python added support for type hints. That included an implementation of the Haskell <code>newtype</code> which was cleverly called <code>NewType</code>.</p> <p>As explained in the documentation, Python's <code>NewType</code> is, like most of the typing library, meant for use by static type checkers. This means that, when the code is running, the Newness of the type is erased, leaving just the wrapped type &amp; no way to tell that there was ever a <code>Newtype</code>, either by the code or by Python itself.</p> <p><code>NewerType</code> provides the same kind of wrapper as <code>NewType</code>, but allows (&amp; enforces) type checking at runtime. This means, for example, that if you wrap an <code>int</code> in a <code>NewerType</code>, you can do all of the arithmetic &amp; comparison operations on an instance of that type that you could with a normal <code>int</code> with either different instances of that type, or <code>int</code>s. But you will not be able to mix different <code>NewerType</code>s, even if they all wrap <code>int</code>s.</p> <p>This allows you to never have to worry if you are adding <code>Miles</code> to <code>Kilometers</code>, or mixing up a <code>UserName</code> with a <code>Password</code>.</p>"},{"location":"#main-features","title":"Main Features","text":"<ul> <li>A wrapper that allows dynamic type checking while mostly not getting in the way</li> <li>Carries type information with the object so you can always use <code>isinstance()</code> or <code>type()</code> to know what it is</li> <li>Forwards the magic methods from the wrapped object so things like arithmetic or indexing work</li> <li>Allows you to customize what methods are forwarded</li> <li>No dependencies!</li> </ul>"},{"location":"#installation","title":"Installation","text":""},{"location":"#using-pip","title":"Using pip","text":"<p>Install the latest stable version: <pre><code>pip install newertype\n</code></pre></p>"},{"location":"#from-source","title":"From source","text":"<pre><code>pip install git+https://github.com/evanjpw/newertype.git\n</code></pre>"},{"location":"#requirements","title":"Requirements","text":"<ul> <li>Python 3.8 or higher</li> <li>No external dependencies!</li> </ul>"},{"location":"#quick-start","title":"Quick Start","text":"<p>Basic usage:</p> <pre><code>from newertype import NewerType\n\nAType = NewerType(\"AType\", int)  # `AType` is a new type that wraps an int\na_type = AType(14)  # Make an instance of this new type\nisinstance(a_type, AType)  # `a_type` is an `AType`\n# Returns: True\nisinstance(a_type, int)  # `a_type` is _NOT_ an `int`\n# Returns: False\nstr(a_type.__class__.__name__) == \"AType\"\n# Returns: True\n</code></pre> <p>You can use the new type as if it's the wrapped type:</p> <pre><code>AType = NewerType(\"AType\", int)\na_type_1 = AType(7)\na_type_2 = AType(7)\na_type_1 == a_type_2  # You can compare them as if they were just `int`s\n# Returns: True\n\nEType = NewerType(\"EType\", int)\ne_type_1 = EType(7)\ne_type_2 = EType(14)\ne_type_2 &gt; e_type_1  # All of the `int` operations work\n# Returns: True\na_type_1 == e_type_1  # But different types are not equal, even if the wrapped value is\n# Returns: False\n\nIType = NewerType(\"IType\", int)\ni_type_1 = IType(7)\ni_type_2 = IType(14)\ni_type_1 + i_type_2  # Arithmetic works!\n# Returns: 21\n\nJType = NewerType(\"JType\", int)\nj_type_1 = JType(7)\ni_type_1 + j_type_1  # But not if you try to mix `NewerType`s\n# TypeError: unsupported operand type(s) for +: 'IType' and 'JType'\n</code></pre>"},{"location":"#next-steps","title":"Next Steps","text":"<ul> <li>Check out the API Reference for detailed documentation</li> <li>See the Changelog for version history</li> </ul>"},{"location":"api/","title":"API Reference","text":""},{"location":"api/#newertype","title":"NewerType","text":""},{"location":"api/#newertype.NewerType","title":"<code>NewerType(name, the_contained_type, **kwargs)</code>","text":"<p>Create a new type that wraps an existing type with runtime type checking.</p> <p>This function creates a new type that wraps the specified type, allowing runtime type checking while maintaining transparency for most operations. Instances of different NewerTypes are not compatible even if they wrap the same underlying type.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name for the new type.</p> required <code>the_contained_type</code> <code>Type[T]</code> <p>The type to wrap.</p> required <code>**kwargs</code> <p>Optional arguments: - extra_forwards: List of additional method names to forward   from the wrapped type. - no_def_forwards: If True, don't forward the default set of   magic methods.</p> <code>{}</code> <p>Returns:</p> Type Description <code>type</code> <p>A new type class that wraps the specified type.</p> Example <p>UserId = NewerType(\"UserId\", int) user_id = UserId(42) isinstance(user_id, UserId) True isinstance(user_id, int) False</p> Source code in <code>newertype/newertype.py</code> <pre><code>def NewerType(name: str, the_contained_type: Type[T], **kwargs) -&gt; type:  # noqa: N802\n    \"\"\"Create a new type that wraps an existing type with runtime type checking.\n\n    This function creates a new type that wraps the specified type, allowing\n    runtime type checking while maintaining transparency for most operations.\n    Instances of different NewerTypes are not compatible even if they wrap\n    the same underlying type.\n\n    Args:\n        name: The name for the new type.\n        the_contained_type: The type to wrap.\n        **kwargs: Optional arguments:\n            - extra_forwards: List of additional method names to forward\n              from the wrapped type.\n            - no_def_forwards: If True, don't forward the default set of\n              magic methods.\n\n    Returns:\n        A new type class that wraps the specified type.\n\n    Example:\n        &gt;&gt;&gt; UserId = NewerType(\"UserId\", int)\n        &gt;&gt;&gt; user_id = UserId(42)\n        &gt;&gt;&gt; isinstance(user_id, UserId)\n        True\n        &gt;&gt;&gt; isinstance(user_id, int)\n        False\n    \"\"\"\n    extra_forwards: List[str] = kwargs.get(\"extra_forwards\", list())\n    no_def_forwards: bool = kwargs.get(\"no_def_forwards\", False)\n\n    class NewerTypeInstance(\n        Generic[T],\n        metaclass=NewerTypeType,\n        class_name=name,\n        the_contained_type=the_contained_type,\n        extra_forwards=extra_forwards,\n        no_def_forwards=no_def_forwards,\n    ):\n        \"\"\"Instance class for NewerType wrappers.\n\n        This class is dynamically created for each NewerType and wraps\n        the actual contained value.\n        \"\"\"\n\n        _contents: T\n\n        def __init__(self, *args, **kwargs) -&gt; None:\n            \"\"\"Initialize a NewerType instance.\n\n            Args:\n                *args: Positional arguments to pass to the wrapped type constructor.\n                **kwargs: Keyword arguments to pass to the wrapped type constructor.\n            \"\"\"\n            self._contents = the_contained_type(*args, **kwargs)\n            super().__init__()\n\n        def __str__(self):\n            \"\"\"Return string representation showing the type name and value.\"\"\"\n            return f\"{self.__class__.__name__}({str(self._contents)})\"\n\n        def __repr__(self):\n            \"\"\"Return representation (same as __str__).\"\"\"\n            return str(self)\n\n        def __bool__(self):\n            \"\"\"Return truthiness of the wrapped value.\"\"\"\n            return bool(self._contents)\n\n        def __bytes__(self, *args):\n            \"\"\"Convert to bytes.\n\n            For strings, uses UTF-8 encoding by default.\n            For other types, delegates to the wrapped type's bytes conversion.\n            \"\"\"\n            encoding = [\"utf-8\"] if isinstance(self._contents, str) else []\n            return bytes(self._contents, *encoding)\n\n        @property\n        def inner(self) -&gt; T:\n            \"\"\"Get the wrapped value.\n\n            Returns:\n                The wrapped value of type T.\n            \"\"\"\n            return self._contents\n\n        @inner.setter\n        def inner(self, value: T) -&gt; None:\n            \"\"\"Set the wrapped value.\n\n            Args:\n                value: New value to wrap.\n            \"\"\"\n            self._contents = value\n\n    return NewerTypeInstance\n</code></pre>"},{"location":"api/#newertypetype","title":"NewerTypeType","text":""},{"location":"api/#newertype.newertype.NewerTypeType","title":"<code>NewerTypeType</code>","text":"<p>               Bases: <code>type</code></p> <p>Metaclass for creating NewerType instances with method forwarding.</p> <p>This metaclass handles the dynamic creation of types that wrap existing types while maintaining runtime type safety. It automatically forwards specified methods from the wrapped type to the wrapper.</p> <p>Attributes:</p> Name Type Description <code>METHODS_TO_FORWARD</code> <code>List[str]</code> <p>List of magic method names to forward by default.</p> Source code in <code>newertype/newertype.py</code> <pre><code>class NewerTypeType(type):\n    \"\"\"Metaclass for creating NewerType instances with method forwarding.\n\n    This metaclass handles the dynamic creation of types that wrap existing\n    types while maintaining runtime type safety. It automatically forwards\n    specified methods from the wrapped type to the wrapper.\n\n    Attributes:\n        METHODS_TO_FORWARD: List of magic method names to forward by default.\n    \"\"\"\n\n    METHODS_TO_FORWARD: List[str] = [\n        \"__len__\",\n        \"__length_hint__\",\n        \"__getitem__\",\n        \"__setitem__\",\n        \"__delitem__\",\n        \"__missing__\",\n        \"__iter__\",\n        \"__reversed__\",\n        \"__contains__\",\n        \"__add__\",\n        \"__sub__\",\n        \"__mul__\",\n        \"__matmul__\",\n        \"__truediv__\",\n        \"__floordiv__\",\n        \"__mod__\",\n        \"__divmod__\",\n        \"__pow__\",\n        \"__lshift__\",\n        \"__rshift__\",\n        \"__and__\",\n        \"__xor__\",\n        \"__or__\",\n        \"__radd__\",\n        \"__rsub__\",\n        \"__rmul__\",\n        \"__rmatmul__\",\n        \"__rtruediv__\",\n        \"__rfloordiv__\",\n        \"__rmod__\",\n        \"__rdivmod__\",\n        \"__rpow__\",\n        \"__rlshift__\",\n        \"__rrshift__\",\n        \"__rand__\",\n        \"__rxor__\",\n        \"__ror__\",\n        \"__iadd__\",\n        \"__isub__\",\n        \"__imul__\",\n        \"__imatmul__\",\n        \"__itruediv__\",\n        \"__ifloordiv__\",\n        \"__imod__\",\n        \"__ipow__\",\n        \"__ilshift__\",\n        \"__irshift__\",\n        \"__iand__\",\n        \"__ixor__\",\n        \"__ior__\",\n        \"__neg__\",\n        \"__pos__\",\n        \"__abs__\",\n        \"__invert__\",\n        \"__complex__\",\n        \"__int__\",\n        \"__float__\",\n        \"__index__\",\n        \"__round__\",\n        \"__trunc__\",\n        \"__floor__\",\n        \"__ceil__\",\n        \"__enter__\",\n        \"__exit__\",\n        \"__eq__\",\n        \"__ne__\",\n        \"__le__\",\n        \"__lt__\",\n        \"__gt__\",\n        \"__ge__\",\n        \"__hash__\",\n        \"__format__\",\n        \"__sizeof__\",\n        \"__copy__\",\n        \"__deepcopy__\",\n    ]\n\n    def __new__(mcs, _name, bases, namespace, **kwargs):\n        \"\"\"Create a new NewerType class.\n\n        Args:\n            _name: Internal name for the class.\n            bases: Base classes.\n            namespace: Class namespace dictionary.\n            **kwargs: Additional arguments including 'the_contained_type'\n                      and 'class_name'.\n\n        Returns:\n            A new class with the specified name and contained type.\n        \"\"\"\n        contained_type = kwargs.get(\"the_contained_type\", Any)\n        namespace[\"contained_type\"] = contained_type\n        name = kwargs.get(\"class_name\", _name)\n        return super().__new__(mcs, name, bases, namespace)\n\n    def __init__(cls, name, bases, namespace, **kwargs):\n        \"\"\"Initialize a NewerType class with method forwarding.\n\n        Args:\n            name: Class name.\n            bases: Base classes.\n            namespace: Class namespace dictionary.\n            **kwargs: Additional arguments including:\n                - extra_forwards: List of additional method names to forward.\n                - no_def_forwards: If True, don't forward default methods.\n        \"\"\"\n        extra_forwards: List[str] = kwargs.get(\"extra_forwards\", list())\n        no_def_forwards: bool = kwargs.get(\"no_def_forwards\", False)\n        methods_to_forward: List[str] = (\n            list() if no_def_forwards else NewerTypeType.METHODS_TO_FORWARD\n        )\n        if extra_forwards:\n            methods_to_forward.extend(extra_forwards)\n        NewerTypeType._forward_methods(cls, namespace, methods_to_forward)\n        super().__init__(name, bases, namespace)\n\n    @staticmethod\n    def _collect_forwardable_methods(\n        contained_type: type, methods_to_forward: List[str]\n    ) -&gt; List[str]:\n        \"\"\"Collect methods that exist on the contained type and should be forwarded.\n\n        Args:\n            contained_type: The type being wrapped.\n            methods_to_forward: List of method names to potentially forward.\n\n        Returns:\n            List of method names that exist on the contained type.\n        \"\"\"\n        contained_dict = contained_type.__dict__\n        to_forward = [k for k in contained_dict if k in methods_to_forward]\n        return to_forward\n\n    @staticmethod\n    def _forward(cls, method_name, namespace):\n        \"\"\"Forward a method from the wrapped type to the wrapper class.\n\n        Args:\n            cls: The wrapper class.\n            method_name: Name of the method to forward.\n            namespace: Class namespace dictionary.\n        \"\"\"\n\n        def forwarded(self, *args, **kwargs):\n            cooked_args = [\n                arg.inner if isinstance(arg, type(self)) else arg for arg in args\n            ]\n            method = getattr(self._contents, method_name)\n            value = method(*cooked_args, **kwargs)\n            return value\n\n        setattr(cls, method_name, forwarded)\n\n    @staticmethod\n    def _forward_methods(\n        cls, namespace: Dict[str, Any], methods_to_forward: List[str]\n    ) -&gt; None:\n        \"\"\"Forward all specified methods from the contained type to the wrapper.\n\n        Args:\n            cls: The wrapper class.\n            namespace: Class namespace dictionary.\n            methods_to_forward: List of method names to forward.\n        \"\"\"\n        contained_type: type = namespace[\"contained_type\"]\n        to_forward = NewerTypeType._collect_forwardable_methods(\n            contained_type, methods_to_forward\n        )\n        for method in to_forward:\n            NewerTypeType._forward(cls, method, namespace)\n</code></pre>"},{"location":"api/#newertype.newertype.NewerTypeType.METHODS_TO_FORWARD","title":"<code>METHODS_TO_FORWARD = ['__len__', '__length_hint__', '__getitem__', '__setitem__', '__delitem__', '__missing__', '__iter__', '__reversed__', '__contains__', '__add__', '__sub__', '__mul__', '__matmul__', '__truediv__', '__floordiv__', '__mod__', '__divmod__', '__pow__', '__lshift__', '__rshift__', '__and__', '__xor__', '__or__', '__radd__', '__rsub__', '__rmul__', '__rmatmul__', '__rtruediv__', '__rfloordiv__', '__rmod__', '__rdivmod__', '__rpow__', '__rlshift__', '__rrshift__', '__rand__', '__rxor__', '__ror__', '__iadd__', '__isub__', '__imul__', '__imatmul__', '__itruediv__', '__ifloordiv__', '__imod__', '__ipow__', '__ilshift__', '__irshift__', '__iand__', '__ixor__', '__ior__', '__neg__', '__pos__', '__abs__', '__invert__', '__complex__', '__int__', '__float__', '__index__', '__round__', '__trunc__', '__floor__', '__ceil__', '__enter__', '__exit__', '__eq__', '__ne__', '__le__', '__lt__', '__gt__', '__ge__', '__hash__', '__format__', '__sizeof__', '__copy__', '__deepcopy__']</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""}]}